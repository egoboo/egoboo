//********************************************************************************************
//*
//*    This file is part of Egoboo.
//*
//*    Egoboo is free software: you can redistribute it and/or modify it
//*    under the terms of the GNU General Public License as published by
//*    the Free Software Foundation, either version 3 of the License, or
//*    (at your option) any later version.
//*
//*    Egoboo is distributed in the hope that it will be useful, but
//*    WITHOUT ANY WARRANTY; without even the implied warranty of
//*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//*    General Public License for more details.
//*
//*    You should have received a copy of the GNU General Public License
//*    along with Egoboo.  If not, see <http://www.gnu.org/licenses/>.
//*
//********************************************************************************************

/// @file egolib/Math/Point.hpp
/// @brief Points.
/// @author Michael Heilmann

#pragma once

#include "egolib/Math/_Tuple.hpp"
#include "egolib/Math/_Generator.hpp"
#include "egolib/Math/Vector.hpp"
#include "egolib/Math/VectorSpace.hpp"

namespace Ego {
namespace Math {

/// @brief A point in the \f$n\f$-dimensional Euclidean space.
/// @tparam _EuclideanSpace the Euclidean space over which the points are defined.
template <typename _VectorSpaceType>
struct Point : public Tuple<typename _VectorSpaceType::ScalarType, _VectorSpaceType::dimensionality()> {
public:
    /// @brief The vector space of this vector.
    typedef _VectorSpaceType VectorSpaceType;
    /// @brief The dimensionality.
    static constexpr size_t dimensionality() {
        return VectorSpaceType::dimensionality();
    }
    /// @brief The scalar field type (of the vector space).
    typedef typename VectorSpaceType::ScalarFieldType ScalarFieldType;
    /// @brief The vector type (of the vector space).
    typedef typename VectorSpaceType::VectorType VectorType;
    /// @brief The scalar type (of the scalar field).
    typedef typename VectorSpaceType::ScalarType ScalarType;

public:
    /// @brief The type of this template/template specialization.
    typedef Point<VectorSpaceType> PointType;
    typedef Point<VectorSpaceType> MyType;
    /// @brief The tuple type.
    typedef Tuple<ScalarType, MyType::dimensionality()> TupleType;

    typedef std::make_index_sequence<MyType::dimensionality()> IndexSequence;

public:
    /**
     * @brief Construct this point with the specified element values.
     * @param first, ... rest the element values
     * @pre The number of specified element values must be equal to the dimensionality of the point type.
     * @pre Each specified element value must be convertible into the element type of the point type.
     */
    template<
        typename ... ArgumentTypes,
        typename = 
            std::enable_if_t<
                (1 + sizeof...(ArgumentTypes)) == MyType::dimensionality() &&
                Core::AllConvertible<ScalarType, ArgumentTypes ...>::value
            >
    >
    Point(ScalarType first, ArgumentTypes&& ... rest)
        : TupleType(std::forward<ScalarType>(first), std::forward<ArgumentTypes>(rest) ...) {
        static_assert(dimensionality() == 1 + sizeof ... (rest), "wrong number of arguments");
    }

    /**
     * @brief
     *  Copy-construct this poiint with the values of another point.
     * @param other
     *  the other point
     */
    Point(const MyType& other)
        : TupleType(other) {
        /* Intentionally empty. */
    }

protected:
    /**
     * @brief
     *  Construct this point with the values generated by a sequence generator.
     * @tparam _GeneratorType
     *  the generator type
     * @tparam ... Index
     *  indices 0, 1, ..., dimensionality() - 1
     */
    template <typename _GeneratorType, size_t ... Index>
    Point(const _GeneratorType& generator, std::index_sequence<Index ...>)
        : Point(generator(Index) ...) {}

public:
    /**
     * @brief
     *  Default-construct this point.
     */
    Point()
        : Point(ConstantGenerator<ScalarType>(ScalarFieldType::additiveNeutral()),
                IndexSequence{}) {
        /* Intentionally empty. */
    }

public:
    inline ScalarType& x() {
        static_assert(MyType::dimensionality() >= 1, "cannot call for member x() with dimensionality less than 1");
        return this->at(0);
    }

    inline ScalarType& y() {
        static_assert(MyType::dimensionality() >= 2, "cannot call for member y() with dimensionality less than 2");
        return this->at(1);
    }

    inline ScalarType& z() {
        static_assert(MyType::dimensionality() >= 3, "cannot call for member z() with dimensionality less than 3");
        return this->at(2);
    }

    inline const ScalarType& x() const {
        static_assert(MyType::dimensionality() >= 1, "cannot call for member x() with dimensionality less than 1");
        return this->at(0);
    }

    inline const ScalarType& y() const {
        static_assert(MyType::dimensionality() >= 2, "cannot call for member y() with dimensionality less than 2");
        return this->at(1);
    }

    inline const ScalarType& z() const {
        static_assert(MyType::dimensionality() >= 3, "cannot call for member z() with dimensionality less than 3");
        return this->at(2);
    }

public:
    /**
     * @brief
     *  Assign this point with the values of another point.
     * @param other
     *  the other point
     */
    void assign(const MyType& other) {
        TupleType::assign(other);
    }

public:
    /**
     * @brief
     *  Get if this point equals another point.
     * @param other
     *  the other point
     * @param ulp
     *  see ScalarFieldType::notEqualUlp
     * @return
     *  @a true if this point equals the other point
     */
    bool equalsUlp(const MyType& other, const size_t& ulp) const {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            if (ScalarFieldType::notEqualULP(this->at(i), other.at(i), ulp)) {
                return false;
            }
        }
        return true;
    }

    /**
     * @brief
     *  Get if this point equals another point.
     * @param other
     *  the other point
     * @param tolerance
     *  see ScalarFieldType::notEqualTolerance
     * @return
     *  @a true if this point equals the other point
     */
    bool equalsTolerance(const MyType& other, const ScalarType& tolerance) const {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            if (ScalarFieldType::notEqualTolerance(this->at(i), other.at(i), tolerance)) {
                return false;
            }
        }
        return true;
    }

public:
    bool operator==(const MyType& other) const {
        return TupleUtilities::foldTT(typename ScalarFieldType::EqualsFunctor(), true, *this, other);
    }

    bool operator!=(const MyType& other) const {
        return !(*this == other);
    }

public:
    // As always, return non-const reference in order to allow chaining for the sake of orthogonality.
    MyType& operator=(const MyType& other) {
        assign(other);
        return *this;
    }

public:
    // Core operators.
    MyType operator+(const VectorType& other) const {
        static const typename ScalarFieldType::SumFunctor functor;
        return TupleUtilities::mapTT<MyType>(functor, *this, other, IndexSequence{});
    }

    MyType operator-(const VectorType& other) const {
        static const typename ScalarFieldType::DifferenceFunctor functor;
        return TupleUtilities::mapTT<MyType>(functor, *this, other, IndexSequence{});
    }

    VectorType operator-(const MyType& other) const {
        static const typename ScalarFieldType::DifferenceFunctor functor;
        return TupleUtilities::mapTT<VectorType>(functor, *this, other, IndexSequence{});
    }

public:
    // Derived operators.
    MyType& operator+=(const VectorType& other) {
        *this = *this + other;
        return *this;
    }

    MyType& operator-=(const VectorType& other) {
        *this = *this - other;
        return *this;
    }

public:
    ScalarType& operator[](size_t const& index) {
        return this->at(index);
    }

    const ScalarType& operator[](size_t const& index) const {
        return this->at(index);
    }

public:
    /**
     * @brief
     *  Get the zero point.
     * @return
     *  the zero point
     */
    static const MyType& zero() {
        static const ConstantGenerator<ScalarType> g(ScalarFieldType::additiveNeutral());
        static const auto v = MyType(g, IndexSequence{});
        return v;
    }


private:
    /**
    * @brief Invoke the constructor of type <tt>TargetType</tt> with
    * passing the arguments <tt>source[0]</tt>,<tt>source[1]</tt>, ...,
    * <tt>source[n]</tt>.
    * @todo Can we re-use this in other places?
    */
    template <typename TargetType, typename SourceType, std::size_t... Index>
    static decltype(auto) invoke(const SourceType& source, std::index_sequence<Index ...>) {
        return TargetType(source[Index]...);
    }

public:
    static decltype(auto) toVector(const PointType& source) {
        return invoke<VectorType>(source, std::make_index_sequence<MyType::dimensionality()>{});
    }
    static decltype(auto) toPoint(const VectorType& source) {
        return invoke<PointType>(source, std::make_index_sequence<MyType::dimensionality()>{});
    }

}; // struct Point

} // namespace Math
} // namespace Ego
